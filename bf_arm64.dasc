|.arch arm64
|.actionlist actions
|.section code

// ARM64-specific wrapper functions
static int putchar_wrapper(int c) {
    return putchar(c);
}

static int getchar_wrapper(void) {
    return getchar();
}

// ARM64-specific compilation function
static void compile_bf_arch(dasm_State **Dst, char instruction) {
    switch (instruction) {
        case '>':
            |  add x19, x19, #1
            break;
        case '<':
            |  sub x19, x19, #1
            break;
        case '+':
            |  ldrb w0, [x19]
            |  add w0, w0, #1
            |  strb w0, [x19]
            break;
        case '-':
            |  ldrb w0, [x19]
            |  sub w0, w0, #1
            |  strb w0, [x19]
            break;
        case '.':
            |  ldrb w0, [x19]
            |  sxtb w0, w0
            |  mov x16, #(uintptr_t)putchar_wrapper & 0xffff
            |  movk x16, #((uintptr_t)putchar_wrapper >> 16) & 0xffff, lsl #16
            |  movk x16, #((uintptr_t)putchar_wrapper >> 32) & 0xffff, lsl #32
            |  movk x16, #((uintptr_t)putchar_wrapper >> 48) & 0xffff, lsl #48
            |  blr x16
            break;
        case ',':
            |  mov x16, #(uintptr_t)getchar_wrapper & 0xffff
            |  movk x16, #((uintptr_t)getchar_wrapper >> 16) & 0xffff, lsl #16
            |  movk x16, #((uintptr_t)getchar_wrapper >> 32) & 0xffff, lsl #32
            |  movk x16, #((uintptr_t)getchar_wrapper >> 48) & 0xffff, lsl #48
            |  blr x16
            |  strb w0, [x19]
            break;
    }
}

// ARM64-specific optimized compilation function with run-length encoding
static void compile_bf_arch_optimized(dasm_State **Dst, char instruction, int count) {
    switch (instruction) {
        case '>':
            if (count == 1) {
                |  add x19, x19, #1
            } else if (count <= 4095) {
                |  add x19, x19, #count
            } else {
                // Handle large counts that don't fit in immediate
                |  mov x16, #count
                |  add x19, x19, x16
            }
            break;
        case '<':
            if (count == 1) {
                |  sub x19, x19, #1
            } else if (count <= 4095) {
                |  sub x19, x19, #count
            } else {
                // Handle large counts that don't fit in immediate
                |  mov x16, #count
                |  sub x19, x19, x16
            }
            break;
        case '+':
            if (count == 1) {
                |  ldrb w0, [x19]
                |  add w0, w0, #1
                |  strb w0, [x19]
            } else if (count <= 255) {
                |  ldrb w0, [x19]
                |  add w0, w0, #count
                |  strb w0, [x19]
            } else {
                // Handle large counts or overflow
                |  ldrb w0, [x19]
                |  mov w16, #count
                |  add w0, w0, w16
                |  strb w0, [x19]
            }
            break;
        case '-':
            if (count == 1) {
                |  ldrb w0, [x19]
                |  sub w0, w0, #1
                |  strb w0, [x19]
            } else if (count <= 255) {
                |  ldrb w0, [x19]
                |  sub w0, w0, #count
                |  strb w0, [x19]
            } else {
                // Handle large counts or overflow
                |  ldrb w0, [x19]
                |  mov w16, #count
                |  sub w0, w0, w16
                |  strb w0, [x19]
            }
            break;
    }
}

// ARM64-specific clear cell optimization for [-] pattern
static void compile_bf_clear_cell(dasm_State **Dst) {
    |  mov w0, #0
    |  strb w0, [x19]
}

// ARM64-specific copy right-to-left optimization for >[-<+>]< pattern
static void compile_bf_copy_right_to_left(dasm_State **Dst) {
    |  ldrb w0, [x19, #1]     // Load from cell[ptr+1] 
    |  strb w0, [x19]         // Store to cell[ptr]
    |  mov w0, #0             // Clear temp register
    |  strb w0, [x19, #1]     // Clear source cell[ptr+1]
}

// ARM64-specific copy current-to-left optimization for [-<+>] pattern  
static void compile_bf_copy_current_to_left(dasm_State **Dst) {
    |  ldrb w0, [x19]         // Load from cell[ptr] (current)
    |  strb w0, [x19, #-1]    // Store to cell[ptr-1] (left) 
    |  mov w0, #0             // Clear temp register
    |  strb w0, [x19]         // Clear current cell[ptr]
}

static void compile_bf_prologue(dasm_State **Dst) {
    |  stp x29, x30, [sp, #-32]!
    |  mov x29, sp
    |  str x19, [sp, #16]
    |  mov x19, x0
}

static void compile_bf_epilogue(dasm_State **Dst) {
    |  mov w0, #0
    |  ldr x19, [sp, #16]
    |  ldp x29, x30, [sp], #32
    |  ret
}

static void compile_bf_loop_start(dasm_State **Dst, int loop_end) {
    |  ldrb w0, [x19]
    |  cbz w0, =>(loop_end)
}

static void compile_bf_loop_end(dasm_State **Dst, int back_to_start) {
    |  ldrb w0, [x19]
    |  cbnz w0, =>(back_to_start)
}

static void compile_bf_label(dasm_State **Dst, int label) {
    |=>(label):
}

// AST-based compilation wrapper functions
static void compile_bf_move_ptr(dasm_State **Dst, int count) {
    if (count > 0) {
        compile_bf_arch_optimized(Dst, '>', count);
    } else if (count < 0) {
        compile_bf_arch_optimized(Dst, '<', -count);
    }
}

static void compile_bf_add_val(dasm_State **Dst, int count) {
    if (count > 0) {
        compile_bf_arch_optimized(Dst, '+', count);
    } else if (count < 0) {
        compile_bf_arch_optimized(Dst, '-', -count);
    }
}

static void compile_bf_input(dasm_State **Dst) {
    compile_bf_arch(Dst, ',');
}