|.arch arm64
|.actionlist actions
|.section code

// Access to global unsafe mode flag
extern bool g_unsafe_mode;

// ARM64-specific wrapper functions
static int putchar_wrapper(int c) {
    return putchar(c);
}

static int getchar_wrapper(void) {
    int c = getchar();
    if (c == EOF) return 0;
    return c;
}

// ARM64-specific copy cell optimization (copy only, no clearing)
static void compile_bf_copy_cell(dasm_State **Dst, int src_offset, int dst_offset) {
    if (!g_unsafe_mode) {
        // Safe mode: use masking
        if (src_offset == 0) {
            |  and x16, x20, x21
            |  ldrb w0, [x19, x16]
        } else {
            |  mov x16, #src_offset
            |  add x16, x20, x16
            |  and x16, x16, x21
            |  ldrb w0, [x19, x16]
        }

        if (dst_offset == 0) {
            |  and x17, x20, x21
            |  ldrb w1, [x19, x17]
            |  add w0, w0, w1
            |  strb w0, [x19, x17]
        } else {
            |  mov x17, #dst_offset
            |  add x17, x20, x17
            |  and x17, x17, x21
            |  ldrb w1, [x19, x17]
            |  add w0, w0, w1
            |  strb w0, [x19, x17]
        }
    } else {
        // Unsafe mode: direct access like pre-masking version
        if (src_offset == 0) {
            |  ldrb w0, [x19, x20]
        } else if (src_offset > 0 && src_offset <= 4095) {
            |  add x16, x20, #src_offset
            |  ldrb w0, [x19, x16]
        } else if (src_offset < 0 && (-src_offset) <= 4095) {
            |  sub x16, x20, #(-src_offset)
            |  ldrb w0, [x19, x16]
        } else {
            |  mov x16, #src_offset
            |  add x16, x20, x16
            |  ldrb w0, [x19, x16]
        }

        if (dst_offset == 0) {
            |  ldrb w1, [x19, x20]
            |  add w0, w0, w1
            |  strb w0, [x19, x20]
        } else if (dst_offset > 0 && dst_offset <= 4095) {
            |  add x17, x20, #dst_offset
            |  ldrb w1, [x19, x17]
            |  add w0, w0, w1
            |  strb w0, [x19, x17]
        } else if (dst_offset < 0 && (-dst_offset) <= 4095) {
            |  sub x17, x20, #(-dst_offset)
            |  ldrb w1, [x19, x17]
            |  add w0, w0, w1
            |  strb w0, [x19, x17]
        } else {
            |  mov x17, #dst_offset
            |  add x17, x20, x17
            |  ldrb w1, [x19, x17]
            |  add w0, w0, w1
            |  strb w0, [x19, x17]
        }
    }
}

// ARM64-specific multiplication optimization
static void compile_bf_mul(dasm_State **Dst, int multiplier, int src_offset, int dst_offset) {
    // Skip zero multiplier
    if (multiplier == 0) return;

    if (!g_unsafe_mode) {
        // Safe mode: use masking
        if (src_offset == 0) {
            |  and x16, x20, x21
            |  ldrb w0, [x19, x16]
        } else if (src_offset > 0 && src_offset <= 4095) {
            |  add x16, x20, #src_offset
            |  and x16, x16, x21
            |  ldrb w0, [x19, x16]
        } else if (src_offset < 0 && (-src_offset) <= 4095) {
            |  sub x16, x20, #(-src_offset)
            |  and x16, x16, x21
            |  ldrb w0, [x19, x16]
        } else {
            |  mov x16, #src_offset
            |  add x16, x20, x16
            |  and x16, x16, x21
            |  ldrb w0, [x19, x16]
        }

        if (dst_offset == 0) {
            |  and x17, x20, x21
            |  ldrb w1, [x19, x17]
        } else if (dst_offset > 0 && dst_offset <= 4095) {
            |  add x17, x20, #dst_offset
            |  and x17, x17, x21
            |  ldrb w1, [x19, x17]
        } else if (dst_offset < 0 && (-dst_offset) <= 4095) {
            |  sub x17, x20, #(-dst_offset)
            |  and x17, x17, x21
            |  ldrb w1, [x19, x17]
        } else {
            |  mov x17, #dst_offset
            |  add x17, x20, x17
            |  and x17, x17, x21
            |  ldrb w1, [x19, x17]
        }
        |  mov w2, #multiplier
        |  mul w3, w0, w2
        |  add w1, w1, w3
        |  strb w1, [x19, x17]
    } else {
        // Unsafe mode: direct access like pre-masking version
        if (src_offset == 0) {
            |  ldrb w0, [x19, x20]
        } else if (src_offset > 0 && src_offset <= 4095) {
            |  add x16, x20, #src_offset
            |  ldrb w0, [x19, x16]
        } else if (src_offset < 0 && (-src_offset) <= 4095) {
            |  sub x16, x20, #(-src_offset)
            |  ldrb w0, [x19, x16]
        } else {
            |  mov x16, #src_offset
            |  add x16, x20, x16
            |  ldrb w0, [x19, x16]
        }

        if (dst_offset == 0) {
            |  ldrb w1, [x19, x20]
        } else if (dst_offset > 0 && dst_offset <= 4095) {
            |  add x17, x20, #dst_offset
            |  ldrb w1, [x19, x17]
        } else if (dst_offset < 0 && (-dst_offset) <= 4095) {
            |  sub x17, x20, #(-dst_offset)
            |  ldrb w1, [x19, x17]
        } else {
            |  mov x17, #dst_offset
            |  add x17, x20, x17
            |  ldrb w1, [x19, x17]
        }
        |  mov w2, #multiplier
        |  mul w3, w0, w2
        |  add w1, w1, w3
        if (dst_offset == 0) {
            |  strb w1, [x19, x20]
        } else {
            |  strb w1, [x19, x17]
        }
    }
}

static void compile_bf_prologue(dasm_State **Dst, size_t memory_size) {
    |  stp x29, x30, [sp, #-64]!
    |  mov x29, sp
    |  str x19, [sp, #16]
    |  str x20, [sp, #24]
    |  str x21, [sp, #32]
    |  mov x19, x0
    |  mov x20, #0
    
    // Compute address mask (memory_size - 1) and store in X21
    size_t mask = memory_size - 1;
    if ((mask & 0xFFFF) == mask) {
        |  mov x21, #mask
    } else if ((mask & 0xFFFFFFFF) == mask) {
        |  mov x21, #(mask & 0xFFFF)
        |  movk x21, #((mask >> 16) & 0xFFFF), lsl #16
    } else {
        |  mov x21, #(mask & 0xFFFF)
        |  movk x21, #((mask >> 16) & 0xFFFF), lsl #16
        |  movk x21, #((mask >> 32) & 0xFFFF), lsl #32
        |  movk x21, #((mask >> 48) & 0xFFFF), lsl #48
    }
}

static void compile_bf_epilogue(dasm_State **Dst) {
    |  mov w0, #0
    |  ldr x21, [sp, #32]
    |  ldr x20, [sp, #24]
    |  ldr x19, [sp, #16]
    |  ldp x29, x30, [sp], #64
    |  ret
}

static void compile_bf_loop_start(dasm_State **Dst, int loop_end) {
    if (!g_unsafe_mode) {
        |  and x16, x20, x21
        |  ldrb w0, [x19, x16]
    } else {
        |  ldrb w0, [x19, x20]              // Load from base + current offset
    }
    |  cbz w0, =>(loop_end)
}

static void compile_bf_loop_end(dasm_State **Dst, int back_to_start) {
    if (!g_unsafe_mode) {
        |  and x16, x20, x21
        |  ldrb w0, [x19, x16]
    } else {
        |  ldrb w0, [x19, x20]              // Load from base + current offset
    }
    |  cbnz w0, =>(back_to_start)
}

static void compile_bf_label(dasm_State **Dst, int label) {
    |=>(label):
}

// Debug label for PC mapping
static void compile_bf_debug_label(dasm_State **Dst, int debug_label) {
    |=>(debug_label):
}

// AST-based compilation wrapper functions
static void compile_bf_move_ptr(dasm_State **Dst, int count) {
    // Modify offset (X20) instead of base address (X19)
    if (count > 0) {
        if (count == 1) {
            |  add x20, x20, #1
        } else if (count <= 4095) {
            |  add x20, x20, #count
        } else {
            |  mov x16, #count
            |  add x20, x20, x16
        }
    } else if (count < 0) {
        int abs_count = -count;
        if (abs_count == 1) {
            |  sub x20, x20, #1
        } else if (abs_count <= 4095) {
            |  sub x20, x20, #abs_count
        } else {
            |  mov x16, #abs_count
            |  sub x20, x20, x16
        }
    }
}

static void compile_bf_add_val(dasm_State **Dst, int count, int offset) {
    if (offset == 0) {
        if (!g_unsafe_mode) {
            |  and x16, x20, x21
            if (count > 0) {
                if (count == 1) {
                    |  ldrb w0, [x19, x16]
                    |  add w0, w0, #1
                    |  strb w0, [x19, x16]
                } else if (count <= 255) {
                    |  ldrb w0, [x19, x16]
                    |  add w0, w0, #count
                    |  strb w0, [x19, x16]
                } else {
                    |  ldrb w0, [x19, x16]
                    |  mov w17, #count
                    |  add w0, w0, w17
                    |  strb w0, [x19, x16]
                }
            } else if (count < 0) {
                int abs_count = -count;
                if (abs_count == 1) {
                    |  ldrb w0, [x19, x16]
                    |  sub w0, w0, #1
                    |  strb w0, [x19, x16]
                } else if (abs_count <= 255) {
                    |  ldrb w0, [x19, x16]
                    |  sub w0, w0, #abs_count
                    |  strb w0, [x19, x16]
                } else {
                    |  ldrb w0, [x19, x16]
                    |  mov w17, #abs_count
                    |  sub w0, w0, w17
                    |  strb w0, [x19, x16]
                }
            }
        } else {
            // Unsafe mode: direct access using x20
            if (count > 0) {
                if (count == 1) {
                    |  ldrb w0, [x19, x20]
                    |  add w0, w0, #1
                    |  strb w0, [x19, x20]
                } else if (count <= 255) {
                    |  ldrb w0, [x19, x20]
                    |  add w0, w0, #count
                    |  strb w0, [x19, x20]
                } else {
                    |  ldrb w0, [x19, x20]
                    |  mov w16, #count
                    |  add w0, w0, w16
                    |  strb w0, [x19, x20]
                }
            } else if (count < 0) {
                int abs_count = -count;
                if (abs_count == 1) {
                    |  ldrb w0, [x19, x20]
                    |  sub w0, w0, #1
                    |  strb w0, [x19, x20]
                } else if (abs_count <= 255) {
                    |  ldrb w0, [x19, x20]
                    |  sub w0, w0, #abs_count
                    |  strb w0, [x19, x20]
                } else {
                    |  ldrb w0, [x19, x20]
                    |  mov w16, #abs_count
                    |  sub w0, w0, w16
                    |  strb w0, [x19, x20]
                }
            }
        }
    } else {
        // Compute effective offset in x16
        if (offset > 0 && offset <= 4095) {
            |  add x16, x20, #offset
        } else if (offset < 0 && (-offset) <= 4095) {
            |  sub x16, x20, #(-offset)
        } else {
            |  mov x17, #offset
            |  add x16, x20, x17
        }
        if (!g_unsafe_mode) {
            |  and x16, x16, x21
        }

        if (count > 0) {
            if (count == 1) {
                |  ldrb w0, [x19, x16]
                |  add w0, w0, #1
                |  strb w0, [x19, x16]
            } else if (count <= 255) {
                |  ldrb w0, [x19, x16]
                |  add w0, w0, #count
                |  strb w0, [x19, x16]
            } else {
                |  ldrb w0, [x19, x16]
                |  mov w17, #count
                |  add w0, w0, w17
                |  strb w0, [x19, x16]
            }
        } else if (count < 0) {
            int abs_count = -count;
            if (abs_count == 1) {
                |  ldrb w0, [x19, x16]
                |  sub w0, w0, #1
                |  strb w0, [x19, x16]
            } else if (abs_count <= 255) {
                |  ldrb w0, [x19, x16]
                |  sub w0, w0, #abs_count
                |  strb w0, [x19, x16]
            } else {
                |  ldrb w0, [x19, x16]
                |  mov w17, #abs_count
                |  sub w0, w0, w17
                |  strb w0, [x19, x16]
            }
        }
    }
}

static void compile_bf_input(dasm_State **Dst, int offset) {
    |  mov x16, #(uintptr_t)getchar_wrapper & 0xffff
    |  movk x16, #((uintptr_t)getchar_wrapper >> 16) & 0xffff, lsl #16
    |  movk x16, #((uintptr_t)getchar_wrapper >> 32) & 0xffff, lsl #32
    |  movk x16, #((uintptr_t)getchar_wrapper >> 48) & 0xffff, lsl #48
    |  blr x16

    if (offset == 0) {
        if (!g_unsafe_mode) {
            |  and x16, x20, x21
            |  strb w0, [x19, x16]
        } else {
            |  strb w0, [x19, x20]
        }
    } else {
        if (offset > 0 && offset <= 4095) {
            |  add x16, x20, #offset
        } else if (offset < 0 && (-offset) <= 4095) {
            |  sub x16, x20, #(-offset)
        } else {
            |  mov x17, #offset
            |  add x16, x20, x17
        }
        if (!g_unsafe_mode) {
            |  and x16, x16, x21
        }
        |  strb w0, [x19, x16]
    }
}

static void compile_bf_output(dasm_State **Dst, int offset) {
    if (offset == 0) {
        if (!g_unsafe_mode) {
            |  and x16, x20, x21
            |  ldrb w0, [x19, x16]
        } else {
            |  ldrb w0, [x19, x20]
        }
    } else {
        if (offset > 0 && offset <= 4095) {
            |  add x16, x20, #offset
        } else if (offset < 0 && (-offset) <= 4095) {
            |  sub x16, x20, #(-offset)
        } else {
            |  mov x17, #offset
            |  add x16, x20, x17
        }
        if (!g_unsafe_mode) {
            |  and x16, x16, x21
        }
        |  ldrb w0, [x19, x16]
    }

    |  sxtb w0, w0
    |  mov x17, #(uintptr_t)putchar_wrapper & 0xffff
    |  movk x17, #((uintptr_t)putchar_wrapper >> 16) & 0xffff, lsl #16
    |  movk x17, #((uintptr_t)putchar_wrapper >> 32) & 0xffff, lsl #32
    |  movk x17, #((uintptr_t)putchar_wrapper >> 48) & 0xffff, lsl #48
    |  blr x17
}

// ARM64-specific set constant optimization
static void compile_bf_set_const(dasm_State **Dst, int value, int offset) {
    if (value == 0) {
        |  mov w0, #0
    } else if (value > 0 && value <= 255) {
        |  mov w0, #value
    } else {
        |  mov w0, #(value & 0xFF)
    }

    if (offset == 0) {
        if (!g_unsafe_mode) {
            |  and x16, x20, x21
            |  strb w0, [x19, x16]
        } else {
            |  strb w0, [x19, x20]
        }
    } else {
        if (offset > 0 && offset <= 4095) {
            |  add x16, x20, #offset
        } else if (offset < 0 && (-offset) <= 4095) {
            |  sub x16, x20, #(-offset)
        } else {
            |  mov x17, #offset
            |  add x16, x20, x17
        }
        if (!g_unsafe_mode) {
            |  and x16, x16, x21
        }
        |  strb w0, [x19, x16]
    }
}
