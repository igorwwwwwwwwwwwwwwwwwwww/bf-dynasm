|.arch x64
|.actionlist actions
|.section code

// AMD64-specific wrapper functions
static int putchar_wrapper(int c) {
    return putchar(c);
}

static int getchar_wrapper(void) {
    int c = getchar();
    if (c == EOF) return 0;
    return c;
}

// AMD64-specific copy cell optimization (copy only, no clearing)
static void compile_bf_copy_cell(dasm_State **Dst, int src_offset, int dst_offset) {
    |  mov rax, [rsp+8]              // Load memory pointer

    // Load from source cell
    if (src_offset >= -128 && src_offset <= 127) {
        |  mov dl, [rax+src_offset]  // Load from source cell at offset
    } else {
        |  add rax, src_offset       // Add src_offset to pointer
        |  mov dl, [rax]             // Load from adjusted pointer
        |  sub rax, src_offset       // Restore pointer
    }

    // Add to destination cell
    if (dst_offset >= -128 && dst_offset <= 127) {
        |  add [rax+dst_offset], dl  // Add to destination cell at offset
    } else {
        |  add rax, dst_offset       // Add dst_offset to pointer
        |  add [rax], dl             // Add to destination cell
        |  sub rax, dst_offset       // Restore pointer
    }
    // Note: Source cell clearing is now handled by explicit SET_CONST(0)
}

// AMD64-specific multiplication optimization
static void compile_bf_mul(dasm_State **Dst, int multiplier, int src_offset, int dst_offset) {
    // Skip zero multiplier
    if (multiplier == 0) return;

    // Load memory pointer and source value
    |  mov rax, [rsp+8]         // Load memory pointer

    // Load from source cell
    if (src_offset >= -128 && src_offset <= 127) {
        |  mov cl, [rax+src_offset]  // Load from source cell at offset
    } else {
        |  add rax, src_offset       // Add src_offset to pointer
        |  mov cl, [rax]             // Load from adjusted pointer
        |  sub rax, src_offset       // Restore pointer
    }

    if (multiplier == 1) {
        // Optimized case: just add source to target
        if (dst_offset >= -128 && dst_offset <= 127) {
            |  add [rax+dst_offset], cl      // target += source
        } else {
            |  add rax, dst_offset           // adjust pointer
            |  add [rax], cl                 // add source
            |  sub rax, dst_offset           // restore pointer
        }
    } else if (multiplier == -1) {
        // Optimized case: subtract source from target
        if (dst_offset >= -128 && dst_offset <= 127) {
            |  sub [rax+dst_offset], cl      // target -= source
        } else {
            |  add rax, dst_offset           // adjust pointer
            |  sub [rax], cl                 // subtract source
            |  sub rax, dst_offset           // restore pointer
        }
    } else {
        // General case: target += source * multiplier
        |  movzx edx, cl             // edx = source (zero-extend to 32-bit)
        |  mov esi, multiplier       // esi = multiplier (use caller-saved ESI instead of EBX)
        |  imul edx, esi             // edx = source * multiplier
        if (dst_offset >= -128 && dst_offset <= 127) {
            |  add [rax+dst_offset], dl      // target += product (use low 8 bits)
        } else {
            |  add rax, dst_offset           // adjust pointer
            |  add [rax], dl                 // add product (use low 8 bits)
            |  sub rax, dst_offset           // restore pointer
        }
    }

    // Note: Counter clearing is now handled by explicit SET_CONST(0) after MUL
}

static void compile_bf_prologue(dasm_State **Dst, size_t memory_size) {
    (void)memory_size; // Unused for now - AMD64 implementation pending
    |  push rbp
    |  mov rbp, rsp
    |  push rdi         // Save memory pointer
    |  sub rsp, 8       // Align stack for function calls (16-byte alignment)
}

static void compile_bf_epilogue(dasm_State **Dst) {
    |  xor eax, eax
    |  add rsp, 16      // Remove alignment padding and memory pointer
    |  pop rbp
    |  ret
}

static void compile_bf_loop_start(dasm_State **Dst, int loop_end) {
    |  mov rax, [rsp+8]      // Load memory pointer from stack
    |  cmp byte [rax], 0     // Compare value at memory pointer
    |  je =>(loop_end)
}

static void compile_bf_loop_end(dasm_State **Dst, int back_to_start) {
    |  mov rax, [rsp+8]      // Load memory pointer from stack
    |  cmp byte [rax], 0     // Compare value at memory pointer
    |  jne =>(back_to_start)
}

static void compile_bf_label(dasm_State **Dst, int label) {
    |=>(label):
}

// Debug label for PC mapping
static void compile_bf_debug_label(dasm_State **Dst, int debug_label) {
    |=>(debug_label):
}

// AST-based compilation wrapper functions
static void compile_bf_move_ptr(dasm_State **Dst, int count) {
    if (count > 0) {
        if (count == 1) {
            |  add qword [rsp+8], 1
        } else {
            |  add qword [rsp+8], count
        }
    } else if (count < 0) {
        int abs_count = -count;
        if (abs_count == 1) {
            |  sub qword [rsp+8], 1
        } else {
            |  sub qword [rsp+8], abs_count
        }
    }
}

static void compile_bf_add_val(dasm_State **Dst, int count, int offset) {
    if (offset == 0) {
        // Normal ADD at current position
        if (count > 0) {
            if (count == 1) {
                |  mov rax, [rsp+8]
                |  inc byte [rax]
            } else if (count <= 127) {
                |  mov rax, [rsp+8]
                |  add byte [rax], count
            } else {
                |  mov rax, [rsp+8]
                |  add byte [rax], count  // x86 allows larger immediates
            }
        } else if (count < 0) {
            int abs_count = -count;
            if (abs_count == 1) {
                |  mov rax, [rsp+8]
                |  dec byte [rax]
            } else if (abs_count <= 127) {
                |  mov rax, [rsp+8]
                |  sub byte [rax], abs_count
            } else {
                |  mov rax, [rsp+8]
                |  sub byte [rax], abs_count  // x86 allows larger immediates
            }
        }
    } else {
        // ADD at offset
        |  mov rax, [rsp+8]              // Load memory pointer
        if (count > 0) {
            if (count == 1 && offset >= -128 && offset <= 127) {
                |  inc byte [rax+offset]     // Increment at offset
            } else if (count <= 127 && offset >= -128 && offset <= 127) {
                |  add byte [rax+offset], count  // Add value at offset
            } else {
                |  add rax, offset           // Add offset to pointer
                |  add byte [rax], count     // Add value at adjusted pointer
            }
        } else if (count < 0) {
            if (count == -1 && offset >= -128 && offset <= 127) {
                |  dec byte [rax+offset]     // Decrement at offset
            } else if (count >= -127 && offset >= -128 && offset <= 127) {
                |  sub byte [rax+offset], -count  // Subtract value at offset
            } else {
                |  add rax, offset           // Add offset to pointer
                |  sub byte [rax], -count    // Subtract value at adjusted pointer
            }
        }
    }
}

static void compile_bf_input(dasm_State **Dst, int offset) {
    |  mov64 rax, (uintptr_t)getchar_wrapper   // Load function pointer
    |  call rax                               // Call through register
    |  mov rdx, [rsp+8]                       // Load memory pointer from stack
    if (offset >= -128 && offset <= 127) {
        |  mov [rdx+offset], al               // Store result at offset
    } else {
        |  add rdx, offset                    // Add offset to pointer
        |  mov [rdx], al                      // Store result at adjusted pointer
    }
}

static void compile_bf_output(dasm_State **Dst, int offset) {
    |  mov rax, [rsp+8]                       // Load memory pointer from stack
    if (offset >= -128 && offset <= 127) {
        |  movzx edi, byte [rax+offset]       // Load byte from offset and put in first argument register
    } else {
        |  add rax, offset                    // Add offset to pointer
        |  movzx edi, byte [rax]              // Load byte and put in first argument register
    }
    |  mov64 rax, (uintptr_t)putchar_wrapper  // Load function pointer into rax
    |  call rax                               // Call through register
}

// AMD64-specific set constant optimization
static void compile_bf_set_const(dasm_State **Dst, int value, int offset) {
    |  mov rax, [rsp+8]              // Load memory pointer
    if (offset >= -128 && offset <= 127) {
        if (value == 0) {
            |  mov byte [rax+offset], 0          // Set to zero at offset
        } else if (value > 0 && value <= 255) {
            |  mov byte [rax+offset], value      // Set positive value at offset
        } else {
            |  mov byte [rax+offset], (value & 0xFF)  // Set value at offset (truncate to byte)
        }
    } else {
        |  add rax, offset           // Add offset to pointer
        if (value == 0) {
            |  mov byte [rax], 0          // Set to zero
        } else if (value > 0 && value <= 255) {
            |  mov byte [rax], value      // Set positive value
        } else {
            |  mov byte [rax], (value & 0xFF)  // Set value (truncate to byte)
        }
    }
}
