|.arch x64
|.actionlist actions
|.section code

// AMD64-specific wrapper functions
static int putchar_wrapper(int c) {
    return putchar(c);
}

static int getchar_wrapper(void) {
    int c = getchar();
    if (c == EOF) return 0;
    return c;
}

// AMD64-specific copy cell optimization (copy only, no clearing)
static void compile_bf_copy_cell(dasm_State **Dst, int src_offset, int dst_offset) {
    // Load from source cell using base+offset addressing
    |  mov rax, rcx                 // rax = current offset
    |  add rax, src_offset          // rax = current offset + src_offset
    |  mov dl, [rbx+rax]            // Load from base[offset + src_offset]

    // Store to destination cell using base+offset addressing
    |  mov rax, rcx                 // rax = current offset
    |  add rax, dst_offset          // rax = current offset + dst_offset
    |  add [rbx+rax], dl            // Add to base[offset + dst_offset]
    // Note: Source cell clearing is now handled by explicit SET_CONST(0)
}

// AMD64-specific multiplication optimization
static void compile_bf_mul(dasm_State **Dst, int multiplier, int src_offset, int dst_offset) {
    // Skip zero multiplier
    if (multiplier == 0) return;

    // Load source value using base+offset addressing
    |  mov rax, rcx                 // rax = current offset
    |  add rax, src_offset          // rax = current offset + src_offset
    |  mov dl, [rbx+rax]            // Load from base[offset + src_offset]

    if (multiplier == 1) {
        // Optimized case: just add source to target
        |  mov rax, rcx             // rax = current offset
        |  add rax, dst_offset      // rax = current offset + dst_offset
        |  add [rbx+rax], dl        // target += source
    } else if (multiplier == -1) {
        // Optimized case: subtract source from target
        |  mov rax, rcx             // rax = current offset
        |  add rax, dst_offset      // rax = current offset + dst_offset
        |  sub [rbx+rax], dl        // target -= source
    } else {
        // General case: target += source * multiplier
        |  movzx edx, dl            // edx = source (zero-extend to 32-bit)
        |  mov esi, multiplier      // esi = multiplier
        |  imul edx, esi            // edx = source * multiplier
        |  mov rax, rcx             // rax = current offset
        |  add rax, dst_offset      // rax = current offset + dst_offset
        |  add [rbx+rax], dl        // target += product (use low 8 bits)
    }

    // Note: Counter clearing is now handled by explicit SET_CONST(0) after MUL
}

static void compile_bf_prologue(dasm_State **Dst, size_t memory_size) {
    (void)memory_size; // Memory size not used yet (no masking for AMD64)
    |  push rbp
    |  mov rbp, rsp
    |  push rbx         // Save RBX (base address register)  
    |  push rcx         // Save RCX (offset register)
    |  sub rsp, 8       // Align stack for function calls (16-byte alignment)
    |  mov rbx, rdi     // RBX = memory base address (passed parameter)
    |  xor rcx, rcx     // RCX = current offset (start at 0)
}

static void compile_bf_epilogue(dasm_State **Dst) {
    |  xor eax, eax
    |  add rsp, 8       // Remove alignment padding
    |  pop rcx          // Restore RCX (offset register)
    |  pop rbx          // Restore RBX (base address register)
    |  pop rbp
    |  ret
}

static void compile_bf_loop_start(dasm_State **Dst, int loop_end) {
    |  cmp byte [rbx+rcx], 0  // Compare value at base[offset]
    |  je =>(loop_end)
}

static void compile_bf_loop_end(dasm_State **Dst, int back_to_start) {
    |  cmp byte [rbx+rcx], 0  // Compare value at base[offset]
    |  jne =>(back_to_start)
}

static void compile_bf_label(dasm_State **Dst, int label) {
    |=>(label):
}

// Debug label for PC mapping
static void compile_bf_debug_label(dasm_State **Dst, int debug_label) {
    |=>(debug_label):
}

// AST-based compilation wrapper functions
static void compile_bf_move_ptr(dasm_State **Dst, int count) {
    if (count > 0) {
        if (count == 1) {
            |  add rcx, 1
        } else {
            |  add rcx, count
        }
    } else if (count < 0) {
        int abs_count = -count;
        if (abs_count == 1) {
            |  sub rcx, 1
        } else {
            |  sub rcx, abs_count
        }
    }
}

static void compile_bf_add_val(dasm_State **Dst, int count, int offset) {
    if (offset == 0) {
        // Normal ADD at current position
        if (count > 0) {
            if (count == 1) {
                |  inc byte [rbx+rcx]
            } else {
                |  add byte [rbx+rcx], count
            }
        } else if (count < 0) {
            int abs_count = -count;
            if (abs_count == 1) {
                |  dec byte [rbx+rcx]
            } else {
                |  sub byte [rbx+rcx], abs_count
            }
        }
    } else {
        // ADD at offset using base+offset addressing
        |  mov rax, rcx              // rax = current offset
        |  add rax, offset           // rax = current offset + additional offset
        if (count > 0) {
            if (count == 1) {
                |  inc byte [rbx+rax]    // Increment at base[offset + additional_offset]
            } else {
                |  add byte [rbx+rax], count  // Add value at base[offset + additional_offset]
            }
        } else if (count < 0) {
            int abs_count = -count;
            if (abs_count == 1) {
                |  dec byte [rbx+rax]    // Decrement at base[offset + additional_offset]
            } else {
                |  sub byte [rbx+rax], abs_count  // Subtract value at base[offset + additional_offset]
            }
        }
    }
}

static void compile_bf_input(dasm_State **Dst, int offset) {
    |  push rcx                              // Save RCX (offset register) before function call
    |  mov64 rax, (uintptr_t)getchar_wrapper   // Load function pointer
    |  call rax                               // Call through register
    |  pop rcx                               // Restore RCX (offset register) after function call
    if (offset == 0) {
        |  mov [rbx+rcx], al                  // Store result at base[offset]
    } else {
        |  mov rdx, rcx                       // rdx = current offset
        |  add rdx, offset                    // rdx = current offset + additional offset
        |  mov [rbx+rdx], al                  // Store result at base[offset + additional_offset]
    }
}

static void compile_bf_output(dasm_State **Dst, int offset) {
    if (offset == 0) {
        |  movzx edi, byte [rbx+rcx]          // Load byte from base[offset] and put in first argument register
    } else {
        |  mov rax, rcx                       // rax = current offset
        |  add rax, offset                    // rax = current offset + additional offset
        |  movzx edi, byte [rbx+rax]          // Load byte from base[offset + additional_offset] and put in first argument register
    }
    |  push rcx                              // Save RCX (offset register) before function call
    |  mov64 rax, (uintptr_t)putchar_wrapper  // Load function pointer into rax
    |  call rax                               // Call through register
    |  pop rcx                               // Restore RCX (offset register) after function call
}

// AMD64-specific set constant optimization
static void compile_bf_set_const(dasm_State **Dst, int value, int offset) {
    if (offset == 0) {
        if (value == 0) {
            |  mov byte [rbx+rcx], 0          // Set to zero at base[offset]
        } else if (value > 0 && value <= 255) {
            |  mov byte [rbx+rcx], value      // Set positive value at base[offset]
        } else {
            |  mov byte [rbx+rcx], (value & 0xFF)  // Set value at base[offset] (truncate to byte)
        }
    } else {
        |  mov rax, rcx              // rax = current offset
        |  add rax, offset           // rax = current offset + additional offset
        if (value == 0) {
            |  mov byte [rbx+rax], 0          // Set to zero at base[offset + additional_offset]
        } else if (value > 0 && value <= 255) {
            |  mov byte [rbx+rax], value      // Set positive value at base[offset + additional_offset]
        } else {
            |  mov byte [rbx+rax], (value & 0xFF)  // Set value at base[offset + additional_offset] (truncate to byte)
        }
    }
}
